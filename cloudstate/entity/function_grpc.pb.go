// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package entity

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// StatelessFunctionClient is the client API for StatelessFunction service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StatelessFunctionClient interface {
	// Handle a unary command.
	//
	// The input command will contain the service name, command name, request metadata and the command
	// payload. The reply may contain a direct reply, a forward or a failure, and it may contain many
	// side effects.
	HandleUnary(ctx context.Context, in *FunctionCommand, opts ...grpc.CallOption) (*FunctionReply, error)
	// Handle a streamed in command.
	//
	// The first message in will contain the request metadata, including the service name and command
	// name. It will not have an associated payload set. This will be followed by zero to many messages
	// in with a payload, but no service name or command name set.
	//
	// If the underlying transport supports per stream metadata, rather than per message metadata, then
	// that metadata will only be included in the metadata of the first message. In contrast, if the
	// underlying transport supports per message metadata, there will be no metadata on the first message,
	// the metadata will instead be found on each subsequent message.
	//
	// The semantics of stream closure in this protocol map 1:1 with the semantics of gRPC stream closure,
	// that is, when the client closes the stream, the stream is considered half closed, and the server
	// should eventually, but not necessarily immediately, send a response message with a status code and
	// trailers.
	//
	// If however the server sends a response message before the client closes the stream, the stream is
	// completely closed, and the client should handle this and stop sending more messages.
	//
	// Either the client or the server may cancel the stream at any time, cancellation is indicated
	// through an HTTP2 stream RST message.
	HandleStreamedIn(ctx context.Context, opts ...grpc.CallOption) (StatelessFunction_HandleStreamedInClient, error)
	// Handle a streamed out command.
	//
	// The input command will contain the service name, command name, request metadata and the command
	// payload. Zero or more replies may be sent, each containing either a direct reply, a forward or a
	// failure, and each may contain many side effects. The stream to the client will be closed when the
	// this stream is closed, with the same status as this stream is closed with.
	//
	// Either the client or the server may cancel the stream at any time, cancellation is indicated
	// through an HTTP2 stream RST message.
	HandleStreamedOut(ctx context.Context, in *FunctionCommand, opts ...grpc.CallOption) (StatelessFunction_HandleStreamedOutClient, error)
	// Handle a full duplex streamed command.
	//
	// The first message in will contain the request metadata, including the service name and command
	// name. It will not have an associated payload set. This will be followed by zero to many messages
	// in with a payload, but no service name or command name set.
	//
	// Zero or more replies may be sent, each containing either a direct reply, a forward or a failure,
	// and each may contain many side effects.
	//
	// If the underlying transport supports per stream metadata, rather than per message metadata, then
	// that metadata will only be included in the metadata of the first message. In contrast, if the
	// underlying transport supports per message metadata, there will be no metadata on the first message,
	// the metadata will instead be found on each subsequent message.
	//
	// The semantics of stream closure in this protocol map 1:1 with the semantics of gRPC stream closure,
	// that is, when the client closes the stream, the stream is considered half closed, and the server
	// should eventually, but not necessarily immediately, close the stream with a status code and
	// trailers.
	//
	// If however the server closes the stream with a status code and trailers, the stream is immediately
	// considered completely closed, and no further messages sent by the client will be handled by the
	// server.
	//
	// Either the client or the server may cancel the stream at any time, cancellation is indicated
	// through an HTTP2 stream RST message.
	HandleStreamed(ctx context.Context, opts ...grpc.CallOption) (StatelessFunction_HandleStreamedClient, error)
}

type statelessFunctionClient struct {
	cc grpc.ClientConnInterface
}

func NewStatelessFunctionClient(cc grpc.ClientConnInterface) StatelessFunctionClient {
	return &statelessFunctionClient{cc}
}

func (c *statelessFunctionClient) HandleUnary(ctx context.Context, in *FunctionCommand, opts ...grpc.CallOption) (*FunctionReply, error) {
	out := new(FunctionReply)
	err := c.cc.Invoke(ctx, "/cloudstate.function.StatelessFunction/handleUnary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statelessFunctionClient) HandleStreamedIn(ctx context.Context, opts ...grpc.CallOption) (StatelessFunction_HandleStreamedInClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StatelessFunction_serviceDesc.Streams[0], "/cloudstate.function.StatelessFunction/handleStreamedIn", opts...)
	if err != nil {
		return nil, err
	}
	x := &statelessFunctionHandleStreamedInClient{stream}
	return x, nil
}

type StatelessFunction_HandleStreamedInClient interface {
	Send(*FunctionCommand) error
	CloseAndRecv() (*FunctionReply, error)
	grpc.ClientStream
}

type statelessFunctionHandleStreamedInClient struct {
	grpc.ClientStream
}

func (x *statelessFunctionHandleStreamedInClient) Send(m *FunctionCommand) error {
	return x.ClientStream.SendMsg(m)
}

func (x *statelessFunctionHandleStreamedInClient) CloseAndRecv() (*FunctionReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(FunctionReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *statelessFunctionClient) HandleStreamedOut(ctx context.Context, in *FunctionCommand, opts ...grpc.CallOption) (StatelessFunction_HandleStreamedOutClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StatelessFunction_serviceDesc.Streams[1], "/cloudstate.function.StatelessFunction/handleStreamedOut", opts...)
	if err != nil {
		return nil, err
	}
	x := &statelessFunctionHandleStreamedOutClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StatelessFunction_HandleStreamedOutClient interface {
	Recv() (*FunctionReply, error)
	grpc.ClientStream
}

type statelessFunctionHandleStreamedOutClient struct {
	grpc.ClientStream
}

func (x *statelessFunctionHandleStreamedOutClient) Recv() (*FunctionReply, error) {
	m := new(FunctionReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *statelessFunctionClient) HandleStreamed(ctx context.Context, opts ...grpc.CallOption) (StatelessFunction_HandleStreamedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StatelessFunction_serviceDesc.Streams[2], "/cloudstate.function.StatelessFunction/handleStreamed", opts...)
	if err != nil {
		return nil, err
	}
	x := &statelessFunctionHandleStreamedClient{stream}
	return x, nil
}

type StatelessFunction_HandleStreamedClient interface {
	Send(*FunctionCommand) error
	Recv() (*FunctionReply, error)
	grpc.ClientStream
}

type statelessFunctionHandleStreamedClient struct {
	grpc.ClientStream
}

func (x *statelessFunctionHandleStreamedClient) Send(m *FunctionCommand) error {
	return x.ClientStream.SendMsg(m)
}

func (x *statelessFunctionHandleStreamedClient) Recv() (*FunctionReply, error) {
	m := new(FunctionReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StatelessFunctionServer is the server API for StatelessFunction service.
// All implementations must embed UnimplementedStatelessFunctionServer
// for forward compatibility
type StatelessFunctionServer interface {
	// Handle a unary command.
	//
	// The input command will contain the service name, command name, request metadata and the command
	// payload. The reply may contain a direct reply, a forward or a failure, and it may contain many
	// side effects.
	HandleUnary(context.Context, *FunctionCommand) (*FunctionReply, error)
	// Handle a streamed in command.
	//
	// The first message in will contain the request metadata, including the service name and command
	// name. It will not have an associated payload set. This will be followed by zero to many messages
	// in with a payload, but no service name or command name set.
	//
	// If the underlying transport supports per stream metadata, rather than per message metadata, then
	// that metadata will only be included in the metadata of the first message. In contrast, if the
	// underlying transport supports per message metadata, there will be no metadata on the first message,
	// the metadata will instead be found on each subsequent message.
	//
	// The semantics of stream closure in this protocol map 1:1 with the semantics of gRPC stream closure,
	// that is, when the client closes the stream, the stream is considered half closed, and the server
	// should eventually, but not necessarily immediately, send a response message with a status code and
	// trailers.
	//
	// If however the server sends a response message before the client closes the stream, the stream is
	// completely closed, and the client should handle this and stop sending more messages.
	//
	// Either the client or the server may cancel the stream at any time, cancellation is indicated
	// through an HTTP2 stream RST message.
	HandleStreamedIn(StatelessFunction_HandleStreamedInServer) error
	// Handle a streamed out command.
	//
	// The input command will contain the service name, command name, request metadata and the command
	// payload. Zero or more replies may be sent, each containing either a direct reply, a forward or a
	// failure, and each may contain many side effects. The stream to the client will be closed when the
	// this stream is closed, with the same status as this stream is closed with.
	//
	// Either the client or the server may cancel the stream at any time, cancellation is indicated
	// through an HTTP2 stream RST message.
	HandleStreamedOut(*FunctionCommand, StatelessFunction_HandleStreamedOutServer) error
	// Handle a full duplex streamed command.
	//
	// The first message in will contain the request metadata, including the service name and command
	// name. It will not have an associated payload set. This will be followed by zero to many messages
	// in with a payload, but no service name or command name set.
	//
	// Zero or more replies may be sent, each containing either a direct reply, a forward or a failure,
	// and each may contain many side effects.
	//
	// If the underlying transport supports per stream metadata, rather than per message metadata, then
	// that metadata will only be included in the metadata of the first message. In contrast, if the
	// underlying transport supports per message metadata, there will be no metadata on the first message,
	// the metadata will instead be found on each subsequent message.
	//
	// The semantics of stream closure in this protocol map 1:1 with the semantics of gRPC stream closure,
	// that is, when the client closes the stream, the stream is considered half closed, and the server
	// should eventually, but not necessarily immediately, close the stream with a status code and
	// trailers.
	//
	// If however the server closes the stream with a status code and trailers, the stream is immediately
	// considered completely closed, and no further messages sent by the client will be handled by the
	// server.
	//
	// Either the client or the server may cancel the stream at any time, cancellation is indicated
	// through an HTTP2 stream RST message.
	HandleStreamed(StatelessFunction_HandleStreamedServer) error
	mustEmbedUnimplementedStatelessFunctionServer()
}

// UnimplementedStatelessFunctionServer must be embedded to have forward compatible implementations.
type UnimplementedStatelessFunctionServer struct {
}

func (UnimplementedStatelessFunctionServer) HandleUnary(context.Context, *FunctionCommand) (*FunctionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleUnary not implemented")
}
func (UnimplementedStatelessFunctionServer) HandleStreamedIn(StatelessFunction_HandleStreamedInServer) error {
	return status.Errorf(codes.Unimplemented, "method HandleStreamedIn not implemented")
}
func (UnimplementedStatelessFunctionServer) HandleStreamedOut(*FunctionCommand, StatelessFunction_HandleStreamedOutServer) error {
	return status.Errorf(codes.Unimplemented, "method HandleStreamedOut not implemented")
}
func (UnimplementedStatelessFunctionServer) HandleStreamed(StatelessFunction_HandleStreamedServer) error {
	return status.Errorf(codes.Unimplemented, "method HandleStreamed not implemented")
}
func (UnimplementedStatelessFunctionServer) mustEmbedUnimplementedStatelessFunctionServer() {}

// UnsafeStatelessFunctionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatelessFunctionServer will
// result in compilation errors.
type UnsafeStatelessFunctionServer interface {
	mustEmbedUnimplementedStatelessFunctionServer()
}

func RegisterStatelessFunctionServer(s *grpc.Server, srv StatelessFunctionServer) {
	s.RegisterService(&_StatelessFunction_serviceDesc, srv)
}

func _StatelessFunction_HandleUnary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FunctionCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatelessFunctionServer).HandleUnary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cloudstate.function.StatelessFunction/handleUnary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatelessFunctionServer).HandleUnary(ctx, req.(*FunctionCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatelessFunction_HandleStreamedIn_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StatelessFunctionServer).HandleStreamedIn(&statelessFunctionHandleStreamedInServer{stream})
}

type StatelessFunction_HandleStreamedInServer interface {
	SendAndClose(*FunctionReply) error
	Recv() (*FunctionCommand, error)
	grpc.ServerStream
}

type statelessFunctionHandleStreamedInServer struct {
	grpc.ServerStream
}

func (x *statelessFunctionHandleStreamedInServer) SendAndClose(m *FunctionReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *statelessFunctionHandleStreamedInServer) Recv() (*FunctionCommand, error) {
	m := new(FunctionCommand)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StatelessFunction_HandleStreamedOut_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FunctionCommand)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StatelessFunctionServer).HandleStreamedOut(m, &statelessFunctionHandleStreamedOutServer{stream})
}

type StatelessFunction_HandleStreamedOutServer interface {
	Send(*FunctionReply) error
	grpc.ServerStream
}

type statelessFunctionHandleStreamedOutServer struct {
	grpc.ServerStream
}

func (x *statelessFunctionHandleStreamedOutServer) Send(m *FunctionReply) error {
	return x.ServerStream.SendMsg(m)
}

func _StatelessFunction_HandleStreamed_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StatelessFunctionServer).HandleStreamed(&statelessFunctionHandleStreamedServer{stream})
}

type StatelessFunction_HandleStreamedServer interface {
	Send(*FunctionReply) error
	Recv() (*FunctionCommand, error)
	grpc.ServerStream
}

type statelessFunctionHandleStreamedServer struct {
	grpc.ServerStream
}

func (x *statelessFunctionHandleStreamedServer) Send(m *FunctionReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *statelessFunctionHandleStreamedServer) Recv() (*FunctionCommand, error) {
	m := new(FunctionCommand)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _StatelessFunction_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cloudstate.function.StatelessFunction",
	HandlerType: (*StatelessFunctionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "handleUnary",
			Handler:    _StatelessFunction_HandleUnary_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "handleStreamedIn",
			Handler:       _StatelessFunction_HandleStreamedIn_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "handleStreamedOut",
			Handler:       _StatelessFunction_HandleStreamedOut_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "handleStreamed",
			Handler:       _StatelessFunction_HandleStreamed_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "function.proto",
}
